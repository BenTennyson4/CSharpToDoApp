<!DOCTYPE html>
<html>
    <head>
        <title>C# to do app</title>
        <meta charset="utf-8">
        <meta name="author" content="Ben Tennyson">
        <meta name="description" content="">
        <link rel="stylesheet" href="/styles/homePageStyles.css">
        <link rel="html" href="index.html"
    </head>
    <body>
        <h1 class="header" id="header"></h1>
    <button id="logoutButton" class="logoutButton" onclick="handleLogout()">Logout</button>
        <div class="toolBar">
            <input type="text" onkeydown="handleListSize(event)" class="listSize" placeholder="Number of tasks">

            <button class="taskDec" onclick="handleTaskDec()">-</button>
            <button class="taskInc" onclick="handleTaskInc()">+</button>

            <button class="saveButton" onclick="putList()">Save List</button>
            <button class="calendarButton" onclick="handleCalendar()">Calendar</button>
            <button class="deleteButton" onclick="deleteList(event)">Delete List</button>
            <label class="reminderToggleLabel"><input type="checkbox" id="enableRemindersCheckbox"> Enable Reminders</label>
        </div>
            <span></span>

        <p class="tasksHeader">Tasks: </p>
        <div class="tasksContainer">
            <div class="taskHeaderRow">
                <span></span>
                <span>Task Name</span>
                <span>Description</span>
                <span>Priority</span>
                <span>Done</span>
            </div>

            <!-- Ordered list container -->
            <ol id="taskList">
            </ol>
        </div>

        <script type="text/javascript">
            // Automatic inactivity logout has been removed so that client-side
            // notifications continue while the page remains open. Logout still
            // happens when the user clicks the Logout button.



            // Set the title of the home page
            let storedUser = localStorage.getItem('username');
            console.log(storedUser)
            // If no user is logged in, ensure redirect to login
            if (!storedUser) {
                window.location.replace('index.html');
            } else {
                document.getElementById("header").innerHTML = storedUser + "'s" + " Home";
            }

            // prevent navigating back to this page after logout by replacing history
            function handleLogout() {
                // Clear local auth/session info
                localStorage.removeItem('username');
                // cancel notifications
                cancelAllNotifications();
                // Redirect to login page and replace history entry so back doesn't return
                window.location.replace('index.html');
            }



            // Get reference to the task list
            const taskList = document.getElementById("taskList");
            // Notification timers keyed by task unique id (listID + '-' + listPosition)
            const notificationTimers = new Map();

            // Request notification permission on page load (best-effort)
            (async function initNotifications() {
                try {
                    // read persisted preference
                    const stored = localStorage.getItem('enableReminders');
                    const enabled = stored === null ? true : stored === 'true';
                    const checkbox = document.getElementById('enableRemindersCheckbox');
                    if (checkbox) checkbox.checked = enabled;

                    if (enabled) {
                        await requestNotificationPermission();
                        // load today's saved list and schedule notifications from it
                        loadTodaySavedList();
                    }
                    // wire up change handler
                    if (checkbox) checkbox.addEventListener('change', async (e) => {
                        const on = e.target.checked;
                        localStorage.setItem('enableReminders', on);
                        if (on) {
                            const ok = await requestNotificationPermission();
                            if (ok) loadTodaySavedList();
                        } else {
                            cancelAllNotifications();
                        }
                    });
                } catch (err) {
                    console.log('Notifications init skipped or failed', err);
                }
            })();



            function handleListSize(event) {
                if (event.key === "Enter") {
                    const desiredSize = parseInt(event.target.value);
                    if (isNaN(desiredSize) || desiredSize < 0) return;

                    // Clear current list
                    taskList.innerHTML = '';

                    // Add desired number of tasks
                    for (let i = 0; i < desiredSize; i++) {
                        addTask();
                    }
                }
            }



            // --- Notification helper functions ---
            async function requestNotificationPermission() {
                if (!('Notification' in window)) return false;
                if (Notification.permission === 'granted') return true;
                if (Notification.permission === 'denied') return false;
                const result = await Notification.requestPermission();
                return result === 'granted';
            }



            function msForPriorityValue(val) {
                // backend stores priority as numbers: 2=High,1=Medium,0=Low
                // return milliseconds interval or null for none
                const n = Number(val);
                if (n === 2) return 60 * 60 * 1000; // 1 hour
                if (n === 1) return 3 * 60 * 60 * 1000; // 3 hours
                return null; // low priority -> no notifications
            }



            function showTaskNotification(task) {
                try {
                    if (!('Notification' in window) || Notification.permission !== 'granted') {
                        // optionally you could show an in-app toast here instead
                        return;
                    }

                    const title = `${task.priority == 2 ? 'High' : task.priority == 1 ? 'Medium' : 'Task'}: ${task.taskName || 'Untitled'}`;
                    const options = {
                        body: task.taskText || '',
                        tag: `today-${task.listPosition}`,
                        renotify: true,
                        requireInteraction: Number(task.priority) === 2
                    };
                    const n = new Notification(title, options);
                    n.onclick = () => {
                        window.focus();
                        n.close();
                    };
                } catch (err) {
                    console.error('Failed to show notification', err);
                }
            }



            function scheduleNotificationsForTasks(tasks) {
                // cancel any existing timers first
                cancelAllNotifications();
                // respect user preference
                const enabled = localStorage.getItem('enableReminders');
                if (enabled === 'false') return;
                if (!Array.isArray(tasks)) return;

                for (const t of tasks) {
                    // Skip tasks that are marked completed
                    if (t.completed === true || t.completed === "true") continue;

                    const ms = msForPriorityValue(t.priority);
                    if (!ms) continue; // skip low priority

                    const key = `${t.listID ?? 'today'}-${t.listPosition ?? Math.random()}`;

                    // show first notification immediately
                    showTaskNotification(t);

                    // schedule repeating notifications while page is open
                    const id = setInterval(() => showTaskNotification(t), ms);
                    notificationTimers.set(key, id);
                }
            }



            function cancelAllNotifications() {
                for (const id of notificationTimers.values()) {
                    clearInterval(id);
                }
                notificationTimers.clear();
            }



            // Load today's saved list from server and schedule notifications from it
            function loadTodaySavedList() {
                const today = new Date();
                const y = today.getFullYear();
                const m = String(today.getMonth() + 1).padStart(2, '0');
                const d = String(today.getDate()).padStart(2, '0');
                const dateString = `${y}-${m}-${d}`; // backend expects YYYY-MM-DD
                fetch(`/getList?Date=${dateString}`)
                    .then(r => r.ok ? r.json() : Promise.reject('no list'))
                    .then(data => {
                        // data should be an array of tasks for that date
                        scheduleNotificationsForTasks(data);
                    })
                    .catch(err => {
                        // no saved list or error - nothing to schedule
                        console.log('No saved list for today or error', err);
                    });
            }



            function handleTaskInc() {
                addTask();
            }



            function handleTaskDec() {
                if (taskList.children.length > 0) {
                    taskList.removeChild(taskList.lastElementChild);
                        updateTaskNumbers();
                    }
            }



            function addTask() {
                // Create the new dom elements
                const li = document.createElement("li");
                const numberDiv = document.createElement('div');
                const nameInput = document.createElement("input");
                const textInput = document.createElement("input");
                const label = document.createElement("label");
                const select = document.createElement("select");
                const completedLabel = document.createElement("label");
                const completedInput = document.createElement("input");

                // Set the attributes of the dom elements
                li.className = "taskRow";
                numberDiv.className = 'taskNumber';
                numberDiv.textContent = (taskList.children.length + 1) + '.';
                nameInput.placeholder = "Task Name";
                nameInput.className = "taskName";
                nameInput.onkeydown = handleTaskNameInput;
                nameInput.type = "text";
                textInput.className = "taskText";
                textInput.type = "text";
                textInput.onkeydown = handleTaskTextInput;
                label.textContent = "Priority: ";
                select.name = "priority";
                label.setAttribute("for", "priority");
                select.className = "prioritySelector";
                select.innerHTML = `
                    <option value="2">High</option>
                    <option value="1">Medium</option>
                    <option value="0">Low</option>
                `;
                // default new tasks to Low priority
                select.value = "0";
                // Configure completed checkbox (per-row)
                completedLabel.className = "completedToggleLabel";
                completedLabel.textContent = ""; // keep label text empty (accessibility via aria)
                completedInput.className = "completedInput";
                completedInput.type = "checkbox";
                completedInput.checked = false;
                completedInput.setAttribute('aria-label', 'Mark task completed');
                completedInput.addEventListener('change', () => {
                    if (completedInput.checked) {
                        // Find the timer key and clear it
                        const position = li.querySelector('.taskNumber')?.textContent.replace('.', '').trim();
                        const key = `today-${position}`;
                        const timer = notificationTimers.get(key);
                        if (timer) {
                            clearInterval(timer);
                            notificationTimers.delete(key);
                        }
                    }
                });


                // Compose the elements and add them to the dom
                const priorityCell = document.createElement('div');
                priorityCell.className = 'priorityCell';
                // keep label for accessibility but visually place next to select
                label.textContent = 'Priority:';
                label.setAttribute('for', 'priority');
                priorityCell.appendChild(label);
                priorityCell.appendChild(select);

                // Append in the same order as the grid: number, name, description, priority, completed
                li.appendChild(numberDiv);
                li.appendChild(nameInput);
                li.appendChild(textInput);
                li.appendChild(priorityCell);
                const completedCell = document.createElement('div');
                completedCell.className = 'completedCell';
                // append a (visually-empty) label for accessibility and the checkbox
                completedCell.appendChild(completedLabel);
                completedCell.appendChild(completedInput);
                li.appendChild(completedCell);
                taskList.appendChild(li);
                updateTaskNumbers();
            }



            function handleTaskNameInput(event) {
                if (event.key === "Enter") {
                    const taskNameInput = event.target;
                    const listItem = taskNameInput.closest("li");
                    if (listItem) {
                        const taskTextInput = listItem.querySelector(".taskText");
                        if (taskTextInput) {
                            taskTextInput.focus();
                        }
                    }
                }
            }



            function handleTaskTextInput(event) {
                if (event.key === "Enter") {
                    const taskTextInput = event.target;
                    const listItem = taskTextInput.closest("li");
                    if (listItem) {
                        const nextListItem = listItem.nextElementSibling;
                        if (nextListItem) {
                            const nextTaskNameInput = nextListItem.querySelector("input.taskName");
                            if (nextTaskNameInput) {
                                nextTaskNameInput.focus();
                            }
                        }
                    }
                }
            }


            
            // Update the visible numbering for each task row
            function updateTaskNumbers() {
                const items = taskList.children;
                for (let i = 0; i < items.length; i++) {
                    const li = items[i];
                    const numDiv = li.querySelector('.taskNumber');
                    if (numDiv) numDiv.textContent = (i + 1) + '.';
                }
            }



            // Create a global variable to track the number of times putList has been called
            // Fix: This counter is not ideal because it might not keep its state when the website is refreshed
            // or when the app is closed (turned off). Maybe either just rely on idempotency of PUT on the server side
            // or find some better way of tracking wheter the list has already been saved on the client side.
            var putListCounter = 0;
            async function putList(event) {
                console.log("Executing putToDoItem in index.html");

                // Generate the listID
                const date = new Date();
                const year = date.getFullYear();
                const month = date.getMonth() + 1;
                const day = date.getDate();
                const listIDString = `${month}${day}${year}`;
                const listID = Number(listIDString);

                // If putList has not been called before insert the record for today's list in the list table
                if (putListCounter === 0) {
                    const listRecord = {
                        listID: listID,
                        userID: 1 // Change to real ID
                    };

                    console.log("Sending list record to backend:", listRecord);
                    try {
                        const response = await fetch("/putList", {
                            method: "PUT",
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: JSON.stringify(listRecord)
                        });

                        const result = await response.text();
                        console.log("Server response:", result);
                        // Schedule notifications based on the saved tasks we just sent
                        try {
                            scheduleNotificationsForTasks(tasks);
                        } catch (err) {
                            console.error('Failed to schedule notifications after save', err);
                        }
                    } catch(err) {
                        console.error("Failed to save task:", err);
                    }
                }

                // Prepare the data to be sent to the backend for insertion in to the DB
                const tasks = [];
                // Get the children elements contained in taskList
                const listItems = taskList.children;
                console.log("Number of list items:", listItems.length);
                // Get the children elements (attributes) of each list element (task) from the ordered list of tasks
                for (let i = 0; i < listItems.length; i++) {
                     const li = listItems[i];

                    // Use optional chaining (?) to ensure that null and undefined values do not throw an error and trim() to remove trailing and leading whitespace
                    const taskName = li.querySelector("input.taskName")?.value.trim();
                    const taskText = li.querySelector("input.taskText")?.value.trim();
                    const priority = li.querySelector("select[name='priority']")?.value;
                    // completed is a checkbox; read its checked state (boolean)
                    const completedEl = li.querySelector("input.completedInput");
                    const completed = completedEl ? Boolean(completedEl.checked) : false;

                    console.log("Raw values:", {
                        taskName: li.querySelector("input.taskName")?.value,
                        taskText: li.querySelector("input.taskText")?.value,
                        priority: li.querySelector("select[name='priority']")?.value,
                        taskText: li.querySelector("input.taskText")?.value,
                    });

                    // Skip empty tasks
                    if (!taskName || !taskText) {
                        console.warn("Skipping task due to missing name or text:", { taskName, taskText });
                        continue;
                    }

                    const task = {
                        completed: completed,
                        priority: priority,
                        taskText: taskText,
                        taskName: taskName,
                        listID: listID,
                        listPosition: i + 1
                    };
                    
                    tasks.push(task);
                }

                console.log("Sending tasks to backend:", tasks);
                    // Send the tasks to the backend
                    try {
                        const response = await fetch("/putTasks", {
                            method: "PUT",
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: JSON.stringify(tasks)
                        });

                        const result = await response.text();
                        console.log("Server response:", result);
                    } catch(err) {
                        console.error("Failed to save task:", err);
                    }
            }



            // Global variables to be shared across the handleCalendar, prevMonth, and nextMonth functions
            let currentMonthIndex;
            let currentYear;
            function handleCalendar() {
                // Get the date 
                const today = new Date();
                // getMonth returns an int 0-11
                if (typeof currentMonthIndex === "undefined") currentMonthIndex = today.getMonth();
                if (typeof currentYear === "undefined") currentYear = today.getFullYear();

                
                const months = [
                    "January", "February", "March", "April", "May", "June", "July", "August",
                    "September", "October", "November", "December"
                ];
                const month = months[currentMonthIndex];

                // Remove existing calendar if any
                const existingCalendar = document.getElementById("calendarContainer");
                if (existingCalendar) {
                    existingCalendar.remove();
                }

                 // Container for calendar
                const calendarContainer = document.createElement("div");
                calendarContainer.id = "calendarContainer";

                // Generate the month header of the calendar
                const headerDiv = document.createElement("div");
                const headerUL = document.createElement("ul");
                const headerNextBt = document.createElement("button");
                const headerPrevBt = document.createElement("button");
                const headerMonthLabel = document.createElement("li");

                headerMonthLabel.innerHTML = `${month}<br><span style="font-size:18px">${currentYear}</span>`;
                headerMonthLabel.id = "monthYearLabel";
                headerNextBt.innerHTML = "&#10095;";
                headerPrevBt.innerHTML = "&#10094;";
                headerNextBt.className = "next";
                headerPrevBt.className = "prev";
                headerUL.className = "month"; 
                headerDiv.className = "calendarHeader";

                // Use arrow functions to pass state
                headerNextBt.onclick = () => {
                    currentMonthIndex++;
                    if (currentMonthIndex > 11) {
                        currentMonthIndex = 0;
                        currentYear++;
                    }
                    handleCalendar();
                };

                headerPrevBt.onclick = () => {
                    currentMonthIndex--;
                    if (currentMonthIndex < 0) {
                        currentMonthIndex = 11;
                        currentYear--;
                    }
                    handleCalendar();
                };

                headerUL.appendChild(headerPrevBt);
                headerUL.appendChild(headerMonthLabel);
                headerUL.appendChild(headerNextBt);

                headerDiv.appendChild(headerUL);

                calendarContainer.appendChild(headerDiv);
                
                // Dynamically generate the days of the calendar using javascript
                const weekDaysUL = document.createElement("ul");
                weekDaysUL.className = "weekdays";
                const weekdays = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
                for (const dayName of weekdays) {
                    const li = document.createElement("li");
                    li.textContent = dayName;
                    weekDaysUL.appendChild(li);
                }

                calendarContainer.appendChild(weekDaysUL);

                // Dynamically generate the calendar days based on the month and the year
                const calendarDays = document.createElement("ul");
                calendarDays.className = "days";
                calendarDays.id = "calendarDays";

                // Get the first day of the month (will be 0-6)
                const firstDay = new Date(currentYear, currentMonthIndex, 1).getDay();
                const daysInMonth = new Date(currentYear, currentMonthIndex + 1, 0).getDate();

                // Add leading empty <li> for alignment
                const startDay = (firstDay + 6) % 7; // Adjust to make Monday = 0
                for (let i = 0; i < startDay; i++) {
                    const li = document.createElement("li");
                    calendarDays.appendChild(li);
                }

                // Match the rest of the days in the month with their weekday names
                for (let day = 1; day <= daysInMonth; day++) {
                    const li = document.createElement("li");
                    const liButton = document.createElement("button");
                    liButton.className = "liButton";
                    liButton.onclick = (event) => fetchList(event);
                    liButton.textContent = day;
                    li.appendChild(liButton);
                    calendarDays.appendChild(li);
                }

                calendarContainer.appendChild(calendarDays);

                // Append the calendar to the body (or another container)
                document.body.appendChild(calendarContainer);

                // Listen for clicks outside the calendar to close it
                setTimeout(() => {
                    const calendar = document.getElementById("calendarContainer");
                    const handleClickOutside = (event) => {
                        if (calendar && !calendar.contains(event.target)) {
                            calendar.remove();
                            document.removeEventListener("click", handleClickOutside);
                        }
                    };

                    document.addEventListener("click", handleClickOutside);
                }, 0);
            }

            

            function fetchList(event) {
                // Get the date clicked on
                const day = event.target.textContent.padStart(2, '0'); // Ensure 2 digits
                const month = (currentMonthIndex + 1).toString().padStart(2, '0'); // Months are 0-indexed
                const year = currentYear;

                const dateString = `${year}-${month}-${day}`; // Format: YYYY-MM-DD

                // Send GET request to backend
                fetch(`/getList?Date=${dateString}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error("Network response was not ok");
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log("Received list data:", data);
                        displayList(data);
                    })
                    .catch(error => {
                        console.error("Error fetching list:", error);
                    });
            }   



            function displayList(listData) {
                // Remove any previous results
                document.querySelectorAll(".retrievedList").forEach(el => el.remove());

                // Create a new ordered list using the data from the fetchList() function
                const list = document.createElement("ul");
                list.className = "retrievedList";

                // Add the list elements of the list
                if (!Array.isArray(listData) || listData.length === 0) {
                    const listElement = document.createElement("li");
                    listElement.className = "retrievedListElement"
                    listElement.textContent = "No list was found for this date";
                    list.appendChild(listElement);
                }
                else {
                    for (let i = 0; i < listData.length; i++) {
                        const item = listData[i];
                        const li = document.createElement("li");
                        li.className = "retrievedListElement";
                        li.textContent = `${item.taskName}: ${item.taskText}`;
                        list.appendChild(li);
                    }
                }

                // Append the result list somewhere visible
                // e.g., under the calendar or at the end of the body
                const calendar = document.getElementById("calendarContainer");
                (calendar ?? document.body).appendChild(list);
            }



            function deleteList(event) {
                // Clear all of the task names and descriptions in the list
                const list = document.querySelector("#taskList");
                if (list) list.replaceChildren(); // empties all children efficiently

                // Send delete request to the server to delete list in the database
                fetch("/deleteList", {
                    method: "DELETE",
                })
                .then(response => {
                    if (response.ok) {
                        console.log('The list for today was deleted successfully.');
                        alert("Today's list deleted");
                    } else {
                        console.error('Failed to delete list.');
                    }
                })
                .catch(error => {
                console.error('Error during fetch:', error);
                });
            }
        </script>
    </body>
</html>